#+OPTIONS: toc:nil
** Chapter one

Go code is organised into packages, which are similar to libraries
or modules in other languages. 
A package consists of one or more =.go= source files in a single 
directory that define what the packages does.

Each source file begins with a =package= declaration, here =package main=
that states which package the file belongs to, followed by a list of
other packages that it imports, and then the declarations of the
program that are stored in that file.

the =fmt= package contains functions for printing formatted output and
scanning input.
=Println= is one of the basic output functions in =fmt=;
it prints one or more values, seperated by spaces, with a newline
character at the end so that the values appear as a single line
of output.

Package =main= is special. It defines a standalone executable 
program, not a library.
Within package main the /function/ main is also special -- it's
where execution of the program begins.
Whatever =main= does is what the program does.
ofcourse, =main= will normally call upon functions in other packages
to do much of the work, such as function =fmt.Println=.


*** Command Line Arguments

The Variable =os.Args= is a /slice/ of strings.
Slices are a fundamental notion in Go.
A slice is a dynamically sized sequence ~s~ of array of elements
where individual elements can be accessed by ~s[i]~ and a 
contiguous subsequence as ~s[m:n]~

The number of elements is given by ~len(s)~.

The first element of ~os.Args~,
=os.Args[0]=, is the name of the command itself;
The other elements are arguments that were presented to the program
when it started execution


#+BEGIN_SRC go
for _, arg := range os.Args[1: ] {
        s += sep + arg
        sep = " "
}
fmt.Println(s)
#+END_SRC


here range produces two values, ~index~ and ~value~ of the element at that index
so arg handles =value= and =_= handles the index

*** Variables
The version of strings above uses short variable declaration
There are several other ways to declare a variable in go

#+BEGIN_SRC go
s := ""
var s = ""
var s string
var s string = ""
#+END_SRC
*** syntax "for" and "if"
The ~for~ loop is the only loop statement in Go. It has a number of forms,
one of which is illustrasted here:

#+BEGIN_SRC go
for initialization; condition; post {
    // zero or more statements
}
#+END_SRC

Parenthesis are never used around the three components of a ~for~ loop.
The braces are mandatory, however, and the openining brace must be on
the same line as the /post/ statement.


The optional /initialization/ statement is executed before the loop starts.
If it is present, it must be a /simple statement/, that is, a short
variable declaration, an increment or assignment statement, or a function
call. The /condition/ is a boolean expression that is evaluated at the
beginning of each iteration of the loop;

if it evaluates to ~true~, the statements controlled by the loop are executed.
The /post/ statement is executed after the body of the loop, then the 
condition is evaluated again. The loop ends when the condition becomes false.

Any of these parts may be omitted. If there is no /initialization/ and no
/post/, the semi-colons may also omitted:

#+BEGIN_SRC go
// a traditional "while" loop
for condition {
    // ...
}
#+END_SRC

If the condition is omitted entirely in any of these forms, for example in
#+BEGIN_SRC go
// a traditional infinite loop
for {
    // ...
}
#+END_SRC

The loop is infinite, though loops of this form may be terminated in
some other way, like a ~break~ or ~return~ statement.


- composite literals in go
- marshal and unmarshal json in go

** json
*** Encoding

To encode JSON data we use the `Marshal` function.

#+BEGIN_SRC go
func Marshal(v interface{}) ([]byte, error)
#+END_SRC

we define a `struct`

#+BEGIN_SRC go
type Message struct {
    Name string
    Body string
    Time int64
}
#+END_SRC

and an instance of this `Message`

#+BEGIN_SRC go
m := Message{"Alice", "Hello", 129}
#+END_SRC

we can marshal a JSON-encoded version of m using `json.Marshal`:

#+BEGIN_SRC go
b, err := json.Marshal(m)
#+END_SRC

we get the following output:

#+BEGIN_SRC go
b == []byte(`{"Name": "Alice", "Body": "Hello", "Time": 129}`)
#+END_SRC

Only datastructures that can be represented as valid `JSON` will be encoded:

- `JSON` objects only support strings as keys;
   to encode a Go map type it must be of the form `map[string]T` (where T is any Go type supported by the json package)

- Channel, complex, and function types cannot be encoded.

- Cyclic data structures are not supported; they will cause Marshal to go into an infinite loop.

- Pointers will be encoded as the values they point to (or 'null' if the pointer is `nil`).

https://blog.golang.org/json-and-go


- interface segregation priciple

    client code should not depend on methods that it does not use.

- Decorator pattern

- Open Close principle

    an entity should be extended without modifying its previous source code.

Go has inferred types, i.e., Go variables have types and they don't change their type

- Generator "goroutines"
  using =goroutines= and =channels= instead of =yield= 